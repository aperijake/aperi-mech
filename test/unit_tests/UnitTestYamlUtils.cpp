#include "UnitTestYamlUtils.h"

#include <vector>

#include "MathUtils.h"

YAML::Node CreateTestYaml() {
    // This is the yaml file that should be generated by the following input file:
    /*
        procedures:
          - explicit_dynamics_procedure:
                geometry:
                    mesh: one_element.exo
                    parts:
                      - part:
                            set: block_1
                            formulation:
                                integration_scheme:
                                  gauss_quadrature:
                                    integration_order: 1
                                approximation_space:
                                  finite_element: ~
                            material:
                                elastic:
                                    density: 7850
                                    youngs_modulus: 2.1e11
                                    poissons_ratio: 0.3
                initial_conditions:
                  - velocity:
                        sets: [block_1]
                        vector:
                            magnitude: 1.23
                            direction: [1.4, -2.5, 2.9]
                loads:
                  - gravity_load:
                        sets: [block_1]
                        vector:
                            magnitude: -9.81
                            direction: [0,0,1]
                time_stepper:
                    direct_time_stepper:
                        time_increment: 0.1
                        time_end: 1.0
                output:
                    file: one_element_out.exo
                    time_start: 0.0
                    time_end: 1.0
                    time_increment: 0.1

    */

    YAML::Node root;
    // Create the procedures list
    YAML::Node procedures(YAML::NodeType::Sequence);

    // Create the first procedure
    YAML::Node explicit_dynamics_procedure;
    explicit_dynamics_procedure["explicit_dynamics_procedure"]["geometry"]["mesh"] = "one_element.exo";

    // Create the parts list
    YAML::Node parts(YAML::NodeType::Sequence);

    // Create the first part
    YAML::Node part;
    part["part"]["set"] = "block_1";

    // Create the material
    YAML::Node material;
    material["elastic"]["density"] = 7850;
    material["elastic"]["youngs_modulus"] = 2.1e11;
    material["elastic"]["poissons_ratio"] = 0.3;

    // Create the finite element formulation
    YAML::Node finite_element_formulation;

    // Create the gauss quadrature integration scheme
    YAML::Node gauss_quadrature;
    gauss_quadrature["integration_order"] = 1;

    // Create the formulation
    YAML::Node formulation;
    formulation["integration_scheme"]["gauss_quadrature"] = gauss_quadrature;
    formulation["approximation_space"]["finite_element"] = finite_element_formulation;

    // Add the material to the part
    part["part"]["material"] = material;

    // Add the formulation to the part
    part["part"]["formulation"] = formulation;

    // Add the part to the parts list
    parts.push_back(part);

    // Add the parts list to the procedure
    explicit_dynamics_procedure["explicit_dynamics_procedure"]["geometry"]["parts"] = parts;

    // Create the initial conditions list
    YAML::Node initial_conditions(YAML::NodeType::Sequence);

    // Create the first initial condition
    YAML::Node velocity;
    velocity["velocity"]["sets"] = std::vector<std::string>{"block_1"};
    YAML::Node vector;
    vector["magnitude"] = 1.23;
    std::vector<double> direction = {1.4, -2.5, 2.9};
    aperi::Normalize(direction);  // The code will normalize the direction, but normalize it here to make the test easier to work with
    vector["direction"] = direction;
    velocity["velocity"]["vector"] = vector;

    // Add the initial condition to the list
    initial_conditions.push_back(velocity);

    explicit_dynamics_procedure["explicit_dynamics_procedure"]["initial_conditions"] = initial_conditions;

    // Create the loads list
    YAML::Node loads(YAML::NodeType::Sequence);

    // Create the first load
    YAML::Node gravity_load;
    gravity_load["gravity_load"]["sets"] = std::vector<std::string>{"block_1"};
    YAML::Node gravity_vector;
    gravity_vector["magnitude"] = -9.81;
    gravity_vector["direction"] = std::vector<double>{0.0, 0.0, 1.0};
    gravity_load["gravity_load"]["vector"] = gravity_vector;

    // Add the load to the list
    loads.push_back(gravity_load);

    explicit_dynamics_procedure["explicit_dynamics_procedure"]["loads"] = loads;

    // Create the time stepper
    YAML::Node time_stepper;
    time_stepper["direct_time_stepper"]["time_increment"] = 0.1;
    time_stepper["direct_time_stepper"]["time_end"] = 1.0;

    explicit_dynamics_procedure["explicit_dynamics_procedure"]["time_stepper"] = time_stepper;

    // Create the output section
    YAML::Node output;
    output["file"] = "one_element_out.exo";
    output["time_start"] = 0.0;
    output["time_end"] = 1.0;
    output["time_increment"] = 0.1;

    explicit_dynamics_procedure["explicit_dynamics_procedure"]["output"] = output;

    // Add the procedure to the procedures list
    procedures.push_back(explicit_dynamics_procedure);

    // Add the procedures list to the root node
    root["procedures"] = procedures;

    return root;
}

void AddBoundaryCondition(YAML::Node& root, const std::string& type, bool use_components = false, const std::string& ramp_function_type = "ramp_function", bool add_active_range = false) {
    // Create the boundary conditions list
    YAML::Node boundary_conditions(YAML::NodeType::Sequence);

    // Create the first boundary condition
    YAML::Node bc;
    bc[type]["sets"] = std::vector<std::string>{"block_1"};

    if (use_components) {
        // Create the components and values
        YAML::Node components_and_values;
        components_and_values["X"] = 1.23;
        components_and_values["Y"] = -4.56;
        components_and_values["Z"] = 7.89;
        bc[type]["components"] = components_and_values;
    } else {
        // Create the vector
        YAML::Node bc_vector;
        bc_vector["magnitude"] = 4.56;
        bc_vector["direction"] = std::vector<double>{0.0, 0.0, -1.0};
        bc[type]["vector"] = bc_vector;
    }

    // Create the time function
    YAML::Node time_function;

    // Add the ramp function to the boundary condition
    YAML::Node ramp_function;
    ramp_function["abscissa_values"] = std::vector<double>{0.0, 1.0};
    ramp_function["ordinate_values"] = std::vector<double>{0.0, 1.0};
    time_function[ramp_function_type] = ramp_function;
    bc[type]["time_function"] = time_function;

    // Create the active range
    if (add_active_range) {
        YAML::Node active_range;
        active_range["time_start"] = 0.2;
        active_range["time_end"] = 0.8;
        bc[type]["active_time_range"] = active_range;
    }

    // Add the boundary condition to the list
    boundary_conditions.push_back(bc);

    // Add the boundary conditions list to the root node
    root["procedures"][0]["explicit_dynamics_procedure"]["boundary_conditions"] = boundary_conditions;
}

void AddDisplacementBoundaryConditions(YAML::Node& root, const std::string& ramp_function_type) {
    bool use_components = false;
    AddBoundaryCondition(root, "displacement", use_components, ramp_function_type);
}

void AddDisplacementBoundaryConditionsComponents(YAML::Node& root, const std::string& ramp_function_type) {
    bool use_components = true;
    AddBoundaryCondition(root, "displacement", use_components, ramp_function_type);
}

// Add a displacement boundary condition with active range to the input file
void AddDisplacementBoundaryConditionsWithActiveRange(YAML::Node& root, const std::string& ramp_function_type) {
    bool use_components = false;
    AddBoundaryCondition(root, "displacement", use_components, ramp_function_type, true);
}

// Add a velocity boundary condition to the input file
void AddVelocityBoundaryConditions(YAML::Node& root, const std::string& ramp_function_type) {
    bool use_components = false;
    AddBoundaryCondition(root, "velocity", use_components, ramp_function_type);
}

// Add a velocity boundary condition with active range to the input file
void AddVelocityBoundaryConditionsWithActiveRange(YAML::Node& root, const std::string& ramp_function_type) {
    bool use_components = false;
    AddBoundaryCondition(root, "velocity", use_components, ramp_function_type, true);
}